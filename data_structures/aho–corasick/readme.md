# Aho–Corasick algorithm  
> **Задача:** Пусть дано множество неких строк/паттернов S = {s0, ... si, ... sn} и текст T. Необходимо найти все 
> вхождения строк внутри текста.  

Дли решения данной задачи хорошо подходит алгоритм Ахо-Корасик.  

Пусть дан набор строк в алфавите размера `k` суммарной длины `m`. Алгоритм Ахо-Корасик строит для этого набора строк 
структуру "бор", а затем по этому бору строит автомат, всё за **O(m)** времени и **O(mk)** памяти. Полученный автомат 
уже может использоваться в различных задачах, простейшая из которых - это нахождение всех вхождений каждой строки из 
данного набора в некоторый текст за линейное время.  

## Бор. Построение бора
> [**Бор**](https://neerc.ifmo.ru/wiki/index.php?title=%D0%91%D0%BE%D1%80) (англ. **_trie_**, луч, нагруженное дерево) — 
> структура данных для хранения набора строк, представляющая из себя подвешенное дерево с символами на рёбрах. Строки 
> получаются последовательной записью всех символов, хранящихся на рёбрах между корнем бора и терминальной вершиной. 
> Размер бора линейно зависит от суммы длин всех строк, а поиск в бору занимает время, пропорциональное длине образца.  
> 
> Бор для набора образцов {he,she,his,hers}:
> ![](images/pict1.jpg)  

То есть бор - это дерево с корнем в некоторой вершине Root, ребро дерева подписано некоторой буквой. Все рёбра из одной 
вершины должны иметь разные метки (буквы), кроме ребра, ведущего к предку.  
Каждая вершина бора имеет флаг `leaf`, который равен `true`, если в этой вершине оканчивается какая-либо строка из 
данного набора.  
Базовая структура узла бора может выглядеть так:  
```
struct Node:
    Node son[k] // массив сыновей (k - длина алфавита)
    bool isLeaf // флаг, является ли вершина терминалом
```
Здесь `son[i]` - указатель на вершину, в которую ведёт ребро по символу `i`.  
В начале бор состоит только из одной вершины - корня.  

Теперь реализуем функцию, которая будет добавлять в бор заданную строку `s`.  
Мы встаём в корень бора, смотрим есть ли переход по букве `s[0]`, если да, то просто переходим в эте вершину, если нет - 
создаём новую вершину и кладём в `s[0]`. Затем мы, стоя в стоя в следующей вершине, повторяем процесс для буквы `s[1]` 
и т.д. После окончания процесса помечаем последнюю посещённую вершину флагом `isLeaf = true`.  
```
Node root; // корневая вершина бора (заполненная)
void addString(string s) {
    Node v = root;
    for (int i = 0; i < s.length; i++) {
        char c = s[i] - 'a';
        if (v.son[c] == null) {
            v.son[c] = new Node();
        }
        v = v.son[c];
    }
    v.isLeaf = true;
}
```

**Time complexity создания бора: _O(n)_**, где n - общее кол-во символов во всех строках;  
**Space complexity бора: _O(n)_**, где n - общее кол-во символов во всех строках.  

## Построение автомата  
Пусть мы построили бор для заданного набора строк. Посмотрим на него немного с другой стороны. Если мы рассмотрим любую 
вершину, то строка, которая соответствует ей, является префиксом одной или нескольких строк из набора; то есть каждую 
вершину бора можно понимать как позицию в одной или нескольких строках из набора.  

Фактически, вершины бора можно понимать как состояния [**конечного детерминированного автомата**](https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B5_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D1%8B).  
Находясь в каком-либо состоянии, мы под воздействием какой-то входной буквы переходим в другое состояние — т.е. в 
другую позицию в наборе строк.  Например, если в боре находится только строка `abc` и мы стоим в состоянии 2 (которому 
соответствует состояние `ab`), то под воздействием буквы `c` мы перейдём в состояние 3.  

Т.е. мы можем понимать рёбра бора как переходы в автомате по соответствующей букве.  
Однако одними только рёбрами бора нельзя ограничиваться. Если мы пытаемся выполнить переход по какой-либо букве, а 
соответствующего ребра в боре нет, то мы тем не менее должны перейти в какое-то состояние.  

Более строго, пусть мы находимся в состоянии `p`, которому соответствует некоторая строка `t`, и хотим выполнить переход 
по символу `c`. Если в боре из вершины `p` есть переход по букве `c`, то мы просто переходим по этому ребру и попадаем 
в вершину, которой соответствует строка `tc`. Если же такого ребра нет, то мы должны найти состояние, соответствующее 
наидлиннейшему собственному суффиксу строки `t` (наидлиннейшему из имеющихся в боре), и попытаться выполнить переход по 
букве `c` из него.  
> **_Собественный суффикс_** - значит не совпадающий со всей строкой.  

Например, пусть бор построен по строкам "ab" и "bc", и мы под воздействием строки "ab" перешли в некоторое состояние, 
являющееся листом. Тогда под воздействием буквы "c" мы вынуждены перейти в состояние, соответствующее строке "b", и 
только оттуда выполнить переход по букве "c".  

**Суффиксная ссылка** для каждой вершины `p` - это вершина, в которой оканчивается наидлиннейший собсвтенный суффикс 
строки, соответствующий вершине `p`.  
Единственный особый случай — корень бора; для удобства суффиксную ссылку из него проведём в себя же.  
Теперь мы можем переформулировать утверждение по поводу переходов в автомате так: пока из текущей вершины бора нет 
перехода по соответствующей букве (или пока мы не придём в корень бора), мы должны переходить по суффиксной ссылке.  

Таким образом, мы свели задачу построения автомата к задаче нахождения суффиксных ссылок для всех вершин бора. Однако 
строить эти суффиксные ссылки мы будем, как ни странно, наоборот, с помощью построенных в автомате переходов.  

Заметим, что если мы хотим узнать суффиксную ссылку для некоторой вершины `v`, то мы можем перейти в предка `p` текущей 
вершины (пусть `c` — буква, по которой из `p` есть переход в `v`), затем перейти по его суффиксной ссылке, а затем из 
неё выполнить переход в автомате по букве `c`.  

Таким образом, задача нахождения перехода свелась к задаче нахождения суффиксной ссылки, а задача нахождения суффиксной 
ссылки — к задаче нахождения суффиксной ссылки и перехода, но уже для более близких к корню вершин. Мы получили 
рекурсивную зависимость, но не бесконечную, и, более того, разрешить которую можно за линейное время.  

Перейдём теперь к реализации.  

Заметим, что нам теперь понадобится в каждой вершине хранить ещё `p` - её предка; символ `pch`, по которому из предка 
есть переход в нашу вершину. Также в кадой вершине будем ранить `Node link` - суффиксная ссылка (`null` - если ещё не 
вычислена), и массив `Node go[k]` - переходы в автомате по каждому из символов (`null` - если ещё не вычислен).  

Полная реализация всех необходимых функций:  
```
struct Node:
    Node son[k] // массив сыновей (k - длина алфавита)
    bool isLeaf // флаг, является ли вершина терминалом
    Node p      // предок
    char pch    // символ от родителя к текущему узлу
    Node link   // суффиксная ссылка
    Node go[k]  // переходы в автомате по каждому из символов

Node root = new Node();

void addString(string s) {
    Node v = root;
    for (int i = 0; i < s.length; i++) {
        char c = s[i] - 'a';
        if (v.son[c] == null) {
            v.son[c] = new Node();
            v.son[c].p = v;
            v.son[c].pch = c;
        }
        v = v.son[c];
    }
    v.isLeaf = true;
}

Node getLink(Node v) {
    if (v.link == null) {
        if (v == null || v.p == null) {
            v.link = root;
        } else {
            v.link = go(getLink(v.p), v.pch);
        }
    }
    return t[v].link;
}

Node go(Node v, char c) {
    if (v.go[c] = null) {
        if (v.next[c] != null) {
            v.go[c] = v.next[c];
        } else {
            v.go[c] = v==root ? root : go(getLink(v), c);
        }
    }
    reutrn v.go[c];
}
```

Time complexity: **O(n)**  
Space complexity: **O(n)**  

## Применение  
### Поиск всех строк из заданного набора в тексте  
Дан набор строк, и дан текст. Требуется вывести все вхождения всех строк из набора в данный текст за время 
**O(Len + Ans)**, где Len - длина текста, Ans - размер ответа.  

Построим по данному набору строк бор. Будем теперь обрабатывать текст по одной букве, перемещаясь соответствующим 
образом по дереву, фактически - по состоянию автомата. Ищначально мы находимся в корне дерева. Пусть мы на очередном 
шаге находимся в состоянии `v` и очередная буква текста `c`. Тогда следует переходить в состояние `go(v,c)`, тем самым 
либо увеличивая на 1 длину текущей совпадающей подстроки, либо уменьшая её, переходя по суффиксной ссылке.  

Как теперь узнать по текущему состоянию `v`, имеется ли совпадение с какими-то строками из набора?  
Во-впервых, понятно, что если мы стоим в посеченной вершине (`leaf=true`), то имеется совпадение с тем образцом, который 
в боре оканчивается в вершине `v`.  
Однако это может не единственным совпадением: если мы будем двигаться по префиксным ссылкам, то по ним будем встречать 
подходящие совпадения. Например, если набор строк = `{"dabce", "abc", "bc"}`, а текст = `"dabc"`. Здесь мы перейдём 
по дереву так: `a->b->c`, то есть найдём совпадение `"abc"`, но есть ещё и совпадение `"bc"`.  
Мы могли бы рекурсивно переходить суффиксным ссылка (`link`), и если вершина помечена как `isLeaf = true`, то класть 
слово, к которому она ведёт, в результат.  
Однако можно заметить, что движение по суффиксным ссылкам можно соптимизировать, предварительно посчитав для каждой 
вершины ближайшую к ней помеченную вершину, достижимую по суффиксным ссылкам (это называется "функцией выхода") (далее 
она будет называться `up`).  

В более простом случае, когда надо найти не сами вхождения, а только их количество, можно вместо функции выхода 
посчитать ленивой динамикой количество помеченных вершин, достижимых из текущей вершины `v` по суффиксным ссылкам. Эта 
величина может быть посчитана за `O(n)` в сумме, и тогда для текущего состояния v мы сможем за `O(1)` найти количество 
вхождений всех образцов в текст, оканчивающихся в текущей позиции. Тем самым, задача нахождения суммарного количества 
вхождений может быть решена нами за `O(Len)`.  

## Другой пример реализации с neerc.ifmo.ru  
Здесь `k` - размер алфавита.  

**Структура вершины:**
```
struct Node:
    Nde son[k];                    // массив сыновей
    Node go[k];                    // массив переходов (запоминаем переходы в ленивой рекурсии), 
                                   // используемый для вычисления суффиксных ссылок.
                                   // То есть в автомате мы будем переходить именно по ним, если у узла есть ребёнок
                                   // с такой буквой, то go[i] = son[i]. Если нет, то мы будем идти рекурсивно по узлам
                                   // suffLink до тех пор, пока у этого узла не будет son[i] или пока не дошли до корня. 
                                   // В итоге go[i] будет ссылаться на son[i] или на root. То есть мы всегда должны 
                                   // быть в каком не null состоянии.
    Node parent;                   // вершина родитель
    Node suffLink;                 // суффиксная ссылка (вычисляем в ленивой рекурсии)
    Node up;                       // сжатая суффиксная ссылка (функция выхода).
                                   // Если мы будем переходить рекурсивно по suffLink, то одной из вершин будет наша up.
                                   // Просто up будет ближайшей вершиной из suffLink, у которой параметр isLeaf = true.
    char charToParent;             // символ, ведущий к родителю
    bool isLeaf;                   // флаг, является ли вершина терминалом
    vector<int> leafPatternNumber; // номера строк, за которые отвечает терминал
```

**Функция для вычисления суффиксной ссылки:**
```
Node getSuffixLink(Node v):
    if v.suffLink == null:
        if v == root || v.parent == root:
            v.suffLink = root;
        else:
            v.suffLink = getLink(getSuffixLink(v.parent), c);
    reutrn v.suffLink;
```

**Функция для вычисления перехода:**
```
Node getLink(Node v, char c):
    if v.go[c] == null:
        if v.son[c] != null:
            v.go[c] = v.son[c]
        else if v == root:
            v.go[c] = root;
        else:
            v.go[c] = getLink(getSuffixLink(v), c);
    return v.go[c];
```

**Функция для вычисления сжатой суффиксной ссылки:**
```
Node getUp(Node v):
    if v.up == null:
        if getSuffixLink(v).isLeaf:
            v.up = getSuffixLink(v);
        else if getSuffixLink(v) == root:
            v.up = root
        else:
            v.up = getUp(getSuffixLink(v));
    return v.up;
```

**Функция для добавления строки в бор:**
```
void addString(string s, int patternNumber):
    Node cur = root;
    for i = 0 to s.length-1:
        char c = s.[i];
        if cur.son[c] == null:
            cur.son[c] = new Node();
            cur.son[c].parent = cur;
            cur.son[c].charToParent = c;
            // все остальные показатели cur.son[c] должны быть пустые (false или null)
        cur = cur.son[c];
    cur.isLeaf = true;
    cur.leafPatternNumber.pushBack(patternNumber);
```

**Функция для процессинга текста (поиск, встречается строка или нет):**
```
void processText(string t):
    Node cur = root;
    for i = 0 to t.length-1:
        char c = t[i];
        cur = getLink(cur, c);
        temp = cur;
        while temp != root:
            if temp.isLeaf:
                // !нашли совпадение подстроки!
            temp = getUp(temp);
```

### Конспект составлял по:
* [MAXimal | Алгоритм Ахо-Корасик](https://e-maxx.ru/algo/aho_corasick)
* [ИТМО | Алгоритм Ахо-Корасик](https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%90%D1%85%D0%BE-%D0%9A%D0%BE%D1%80%D0%B0%D1%81%D0%B8%D0%BA)  
* [codereview.stackexchange.com | Aho-Corasick for multiple exact string matching in Java](https://codereview.stackexchange.com/questions/115624/aho-corasick-for-multiple-exact-string-matching-in-java)  

### Ещё норм источники:  
* [презентация | Aho-Corasick Automata](https://github.com/williamfiset/Algorithms/blob/master/references/AhoCorasick.pdf)
* [stackoverflow | Steps of implementation of Aho-Corasick string matching algorithm](https://stackoverflow.com/a/46938655)
* [proglib | Must-have алгоритмы для работы со строками на C++](https://proglib.io/p/must-have-algoritmy-dlya-raboty-so-strokami-na-c-2020-03-30)
* [codeforces | Алгоритм Ахо-Корасик. Построение](https://codeforces.com/blog/entry/14854?locale=ru)
* [algorithmica.org | Алгоритм Ахо-Корасик](https://algorithmica.org/ru/aho-corasick)