# Geometric Applications of BSTs  
Здесь мы рассмотрим как можно использовать структуры данных, в основе которых лежит структура Binary Search Tree, при 
помощи которых можно решать геометрические задачи. То есть такие задачи как поиск пересечений прямых (ортогональных), 
поиск точек внутри пределённого прямоугольника, поиск ближайшей точки и т.д.  
![](images/pict1.png)  

## 1d Range Search  
Используется когда у нас на одной прямой есть ряд точек и нам надо найти список всех точек, которы лежат в данном 
интервале.  
![](images/pict2.png)  
На структура данных должна поддерживать следующие функции:  
- Insert key-value
- Search for key
- Delete by key
- Range-search: find all keys between _k1_ and _k2_
- Range-count: number of keys between _k1_ and _k2_  

Такая структура данных может часто использоваться в БД, где мы делаем запрос на какой-то интервал.  

Если мы будем использовать неотсортированный массив, то у нас будет быстрая вставка, но медленный поиск.
Если отсортированный массив - медленная вставка (все элементы надо будет двигать), но быстрый поиск.  
![](images/pict3.png)  
Добавиться результатов из строки _goal_ нам поможет бинарное дерево поиска.  

#### 1d range count  
Составим бинарное дерево поиска по элементам, где пронумеруем наши элементы по мере проходов по in-order DFS.  
![](images/pict4.png)  
Допустим нам надо найти кол-во элементов в интервале [E:S].  
Мы ищем элемент E (или если его нет, то элемент, который чуть больше).  
Затем ищем элемент S (если нет, то чуть меньше).  
Затем вычитаем номер (rank) меньшего элемента из большего. Если больший присутствует (в нашем случае S), то прибавляем 1.  

Time complexity: **O(logN)**.  

#### 1d range search  
Допустим нам надо найти все элементы между *lo* и *hi*.  
![](images/pict5.png)  
Проверяем, входит ли текущий узел в искомый интервал, если да, то делаем рекурсивный поиск по левым и правым дочерним 
узлам.  
Если текущий узел меньше искомого, то делаем рекурсивный поиск только по правому; если больше, то только по левому.  
Таким образом мы откинем все элементы меньше и больше интервала и пройдёмся по всем элементам внутри интервала.  

Time complexity: **O(R + logN)**, где R - кол-во элементов внутри интервала.  

## Orthogonal line segment intersection  
Задача, которую решает данный алгоритм: дано N горизонтальных и вертикальных отрезков, надо найти все их пересечения.  
![](images/pict6.png)   
Наивный подход (brute force) занимает O(n^2) time complexity, где мы каждый отрезок проверяем с остальными. Нужен способ 
быстрее.  

Метод, который мы будем использовать, называется __*Sweep line algorithm*__.  
 
Мы слева направо начинаем идти по плоскости, и как только встречаем левую точку горизонтального отрезка, то добавляем 
его значение в BST (которую надо создать в начале).  Так мы двигаемся дальше и продолжаем заполнять BST.  
Как только наткнёмся на правую точку отрекза, то удаляем соответствующий отрезок из BST.  
![](images/pict7.png)  

Если мы наткнёмся на вертикальный отрезок, то делаем *1d range search* в BST в интервале вертикального отрезка.  
![](images/pict8.png)  

Sweep-line algorithm занимает **O(N\*logN + R) time complexity**, чтобы найти *R* пересечений среди *N* ортогональных 
отрезков прямых.  
![](images/pict9.png)  

## Kd-Tree  
TODO: законспектировать  

## Interval Search Tree  
1d interval search tree - структура данных, которые позволяет хранить множество (пересекающихся) интервалов.  
Поддерживаемые операции:  
- Insert an interval (lo, hi);
- Search for an interval (lo, hi);
- Delete an interval (lo, hi);
- _Interval intersection query_: дан интервал (lo,hi), найти все интервалы (или только один), которые как-то 
пересекаются с (lo,hi).  
![](images/pict10.png)  

![](images/pict11.png)  

В основе Interval Search Tree лежит BST.  
Здесь каждый узел хранит информацию об интервале (lo, hi) и максимальное hi значение данного поддерева.  
В качестве ключа (сортировки) BST используем lo значение.  
![](images/pict12.png)  
При вставке нового элемента надо не забыть обновлять максимальное hi значение у родительских элементов.
  
Алгоритм поиска одного пересекающегося интервала:  
![](images/pict13.png)  
Так, если гипотетически интервал может быть слева, то мы идём налево. Если его в итоге там не оказалось, то справа 
его уже тоже не будет.  
То есть мы переходим всегда только на одну сторону и уже не проверяем вторую (тк там искомого интервала не будет).  
![](images/pict14.png)  

## Orthogonal rectangle intersection  
Задача: найти все пересечения среди ортогональных прямоугольников.  
![](images/pict15.png)  

Для оптимального решения такой задачи мы используем аналогию вышеупомянутого Sweep-line алгоритма, только здесь мы будем 
работать не точками, а с отрезками. И вместо поиска в BST точек в интервале, будем делать поиск по Interval Search Tree.  
![](images/pict16.png)  
Так, чтобы найти R пересечений среди N ортогональных прямоугольников, потребуется **O(N\*logN + R\*logN)** time 
complexity.  
![](images/pict17.png)  

Sweep line алгоритм преобразует двухмерный поиск пересечений ортогональных прямоугольников в одномерный поиск 
интервалов.  

### Geometric applications of BSTs  
![](images/pict18.png)  

## Список источников  
Конспект составлял по:
* [Сoursera | Geometric applications of BSTs](https://www.coursera.org/learn/algorithms-part1/lecture/ot9vw/)
* [PDF Slides | Geometric applications of BSTs](cursera-abstract.pdf)
* [PDF Slides | Interval Trees](interval_trees.pdf)