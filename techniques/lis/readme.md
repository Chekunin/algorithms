# Longest Increasing Subsequence (LIS)  
> **Определение.** _Подпоследовательностью_ {x<sub>n<sub>k</sub></sub>} называется числовая последовательность, которая 
> составлена из членов последовательности x<sub>n</sub> и в которой порядок следования её элементов совпадает с их 
> порядком следования в исходной последовательности x<sub>n</sub>.  

Подпоследовательность можно получить из некоторой конечной последовательности, если удалить из последней некоторое 
множество её элементов (возможно пустое). Например, BCDB является подпоследовательностью последовательности ABCDBAB.  

Будем говорить, что последовательность Z является общей подпоследовательностью последовательностей X и Y, если Z 
является подпоследовательностью как X, так и Y. Требуется для двух последовательностей X и Y найти общую 
подпоследовательность наибольшей длины. Заметим, что НОП может быть несколько.  

**Обратим внимание!** Подпоследовательность отличается от подстроки. Например, если есть исходная последовательность 
«ABCDEF», то «ACE» будет подпоследовательностью, но не подстрокой, а «ABC» будет как подпоследовательностью, так и 
подстрокой.  

Далее мы рассмотрим задачу, когда дана последовательность чисел и нам надо будет найти возрастающую 
подпоследовательность (LIS) наибольшей длины.  

## Решение за время O(n^2) (dynamic programming)  
Построим массив `d`, где `d[i]` - длина наибольшей возрастающей подпоследовательности, оканчивающейся в элементе, с 
индексом `i`. Массив будем заполнять постепенно — сначала `d[0]`, потом `d[1]` и т.д.  
Ответом на нашу задачу будет максимум из всех элементов массива `d`.  
Заполнение массива будет следующим: если `d[i]=1`, то искомая последовательность состоит только из числа `a[i]`. Если 
`d[i]>1`, то перед числом `a[i]` в подпоследовательности стоит какое-то другое число. Переберем его: это может быть 
любой элемент `a[j](j=0...i−1)`, но такой, что `a[j]<a[i]`.  
Пусть на каком-то шаге нам надо посчитать очередное `d[i]`. Все элементы массива `d` до него уже посчитаны. Значит наше 
`d[i]` мы можем посчитать следующим образом:  
![](images/pict1.png)  
при условии, что `a[j]<a[i]`.

Пока что мы нашли лишь максимальную длину наибольшей возрастающей подпоследовательности, но саму ее мы вывести не можем. 
Для восстановления ответа заведем массив `prev[0...n−1]`, где `prev[i]` будет означать индекс в массиве `a[]`, при 
котором достигалось наибольшее значение `d[i]`. Для вывода ответа будем идти от элемента с максимальным значениям `d[i]` 
по его предкам.  

### Псевдокод алгоритма
```
vector<int> findLIS(vector<int> a):
   int n = a.size //размер исходной последовательности
   int prev[0..n - 1]
   int d[0..n - 1]
 
   for i = 0 to n - 1
       d[i] = 1
       prev[i] = -1
       for j = 0 to i - 1
           if (a[j] < a[i] and d[j] + 1 > d[i])
               d[i] = d[j] + 1
               prev[i] = j
 
   pos = 0       // индекс последнего элемента НВП
   length = d[0] // длина НВП
   for i = 0 to n - 1
       if d[i] > length
           pos = i
           length = d[i]
   
   // восстановление ответа
   vector<int> answer
   while pos != -1
       answer.push_back(a[pos])
       pos = prev[pos]
   reverse(answer)
 
   return answer
```
**Time complexity: O(n^2)**  
**Space complexity: O(n)**

## Решение за время O(n*logn)  
Для более быстрого решения данной задачи построим следующую динамику: пусть `d[i](i=0...n)` - число, на которое 
оканчивается возрастающая последовательность длины `i`, а если таких чисел несколько - то наименьшее из них.  
Изначально мы предполагаем, что `d[0]=-INF`, а все остальные элементы `d[i]=INF`.  
Заметим два важных свойства этой динамики: `d[i−1]⩽d[i]`, для всех i=1...n и каждый элемент `a[i]` обновляет максимум 
один элемент `d[j]`.  
Это означает, что при обработке очередного `a[i]`, мы можем за O(logn) c помощью двоичного поиска в массиве `d` найти 
первое число, которое больше либо равно текущего `a[i]` и обновить его.  

Для восстановления ответа будем поддерживать заполнение двух массивов: `pos` и `prev`.  
В `pos[i]` будем хранить индекс элемента, на который заканчивается оптимальная подпоследовательность длины `i`, а в 
`prev[i]` — позицию предыдущего элемента для `a[i]`.  

_Свой комментарий:_  
По сути мы создаём несколько переменных:  
- int n = a.size.  
- int d[0..n] // ключ - длина подпоследовательности, значение - наименьшее число, на которое она заканчивается.  
- int pos[0..n] // ключ - длина подпоследовательности, значение - индекс числа в исходной последовательности, на 
  который заканчивается оптимальная подпоследовательность длины i (d[i] = a[pos[i]]).  
- int prev[0..n - 1] // ключ - индекс в исходной последовательности, значение - индекс предыдущего числа 
  подпоследовательности в исходной последовательности.  
- int length // наибольшая длина подпоследовательности  

Далее перебираем исходную последовательность, ищем в массиве d подходящую позицию для текущего числа при помощи 
бинарного поиска. Если мы нашли место, в котором предыдущее число меньше текущего и старое число на этой позиции меньше 
текущего, то добавляем его: обновляем его в массиве `d`, обновляет `pos`, в `prev[индекс_числа_в_последовательости]` 
записываем индекс предыдущего числа подпоследовательности.  
Затем восстанавливаем искомую LIS.

### Псевдокод алгоритма  
```
vector<int> findLIS(vector<int> a):
   int n = a.size
   int d[0..n]
   int pos[0..n]
   int prev[0..n - 1]
   int length = 0
   
   pos[0] = -1
   d[0] = INF
   for i = 1 to n
       d[i] = -INF
   for i = 0 to n - 1
       j = binary_search(d, a[i])
       if (d[j - 1] < a[i] and a[i] < d[j])
           d[j] = a[i]
           pos[j] = i
           prev[i] = pos[j - 1]
           length = max(length, j)
   
   // восстановление ответа
   vector<int> answer
   p = pos[length]
   while p != -1
       answer.push_back(a[p])
       p = prev[p]
   reverse(answer)
 
   return answer
```

**Time complexity: O(n\*logn)**  
**Space complexity: O(n)**


## Patience sorting  
**Терпеливая сортировка** _(patience sorting)_ - алгоритм сортировки с худшей сложностью **_O(n\*log n)_**. Позволяет 
также вычислить длину наибольшей возрастающей подпоследовательности данного массива. Алгоритм назван по одному из 
названий карточной игры "Солитёр" — "Patience".  

Его суть заключается в том, что мы создаём несколько стеков (колод кард), изначально их 0.  
В каждую колоду карты добавляются по убыванию (или невозрастанию, зависит от требований).  
Мы берём очередную карту и размещаем её в самую левую колоду, которая подходит для данной карты. Если нет подходящих 
колод, то мы создаём новую справа.  
После добавления новой карты в колоду, мы запоминаем указатель на самую последнюю карту в колоде левее (если текущая 
колода самая левая, не запоминаем).
Поиск подходящей колоды осуществляем при помощи бинарного поиска.  

В конечном итоге мы получим несколько колод карт. Длина _longest increasing subsequence_ (LIS) будет равна кол-ву колод.  
Если у нас получилась одна колода, то это значит, что все числа в изначальном массиве были расположены по убыванию, 
соответственно и длинна LIS будет равна 1.
Чтобы получить LIS, нам надо взять самую последнюю карту из правой колоды (эта карта будет самое большой), дальше взять 
карту на которую эта колода ссылается (карта из колоды левее), и выполнять этот шаг пока указатель не будет null (он 
будет null в самой левой колоде).

Чтобы сформировать отсортированный массив, надо из вершин (самых последних карт) всех колод доставать по одной самой 
маленькой карте. Этот этап займёт O(n) time, предыдущие занимают O(n*logn), поэтому в итоге получим всё равно O(n*logn).  

## Код терпеливой сортировки
```java
import java.util.*;

class Main {
  public static void main(String[] args) {
    long[] arr = {5, 2, 2, 1, 5, 3, 6, 8, 2, 10, 11, 2, 6, 2, 6, 3, 1, 3, 5, 5, 5, 8, 10, 1, 2};
    sort(arr);
    System.out.println(Arrays.toString(arr));
    // [1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 5, 5, 5, 5, 5, 6, 6, 6, 8, 8, 10, 10, 11]
  }


  public static void sort(long[] arr) {
    List<Deque<Long>> piles = buildPiles(arr);
    kWayMerge(piles, arr);
  }

  private static final Comparator<Deque<Long>> PILE_COMPARATOR = (i, j) -> {
    if (i.isEmpty()) return 1; // null is last
    if (j.isEmpty()) return -1; // null is last
    return Long.compare(i.peek(), j.peek());
  };

  private static List<Deque<Long>> buildPiles(long[] elements) {
    List<Deque<Long>> piles = new ArrayList<>();
    for (long v : elements) {
      Deque<Long> pile = new LinkedList<>();
      pile.push(v);
      int index = Collections.binarySearch(piles, pile, PILE_COMPARATOR);

      if (index < 0) index = -index - 1;

      if (index >= piles.size()) piles.add(pile);
      else piles.get(index).push(v);
    }
    return piles;
  }

  private static void kWayMerge(List<Deque<Long>> piles, long[] into) {
    if (piles.isEmpty()) return;

    Queue<Deque<Long>> pq = new PriorityQueue<>(PILE_COMPARATOR);
    pq.addAll(piles);

    for (int i = 0; !pq.peek().isEmpty(); i++) {
      Deque<Long> pile = pq.remove();
      into[i] = pile.pop();
      pq.add(pile); // actually should Re-heapify, but this is not possible with this implementation
    }
  }
}
```
**Time complexity: O(n\*logn)**  
**Space complexity: O(n)**

Код выше описывает только саму сортировку, чтобы получить LIS, нам надо немного изменить алгоритм: каждый раз, когда мы 
кладём новую карту в колоду, нам надо запоминать последнюю карту в колоде левее на данный момент.  
Когда у нас будут готовы все колоды, мы возьмём самую новую карту из последней колоды, затем возьмём карту из колоды 
левее, на которую ссылается та карта. Так будем идти левее пока не дайдём до самой первой колод. Эти карты и будут 
образовывать LIS.  

## Список источников
Конспект составлял по:
* [ИТМО | Задача о наибольшей возрастающей подпоследовательности](https://neerc.ifmo.ru/wiki/index.php?title=%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D0%BD%D0%B0%D0%B8%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B5%D0%B9_%D0%B2%D0%BE%D0%B7%D1%80%D0%B0%D1%81%D1%82%D0%B0%D1%8E%D1%89%D0%B5%D0%B9_%D0%BF%D0%BE%D0%B4%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
* [ИТМО | Терпеливая сортировка](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A2%D0%B5%D1%80%D0%BF%D0%B5%D0%BB%D0%B8%D0%B2%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)
* [PDF | Longest increasing subsequence](https://www.cs.princeton.edu/courses/archive/spring13/cos423/lectures/LongestIncreasingSubsequence.pdf)
* [Github | Patience sort java algorithm](https://github.com/bxt/Ludus/blob/master/unilectures/src/bxt/unilectures/algorithmenunddatenstrukturen/fun/sorting/PatienceSort.java)
* [Числовая подпоследовательность](https://ru.wikiversity.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C)