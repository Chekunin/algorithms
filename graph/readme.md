# Граф. Структура данных.
__Структура данных графа__ представляет собой набор узлов, которые имеют данные и связаны с другими узлами.  

Давайте попробуем понять это на примере. На facebook все является узлом. Сюда входят пользователь, фотография, альбом, событие, группа, страница, комментарий, история, видео, ссылка, примечание ... все, что имеет данные, является узлом.  
Каждое отношение - это ребро от одного узла к другому. Публикуете ли вы фотографию, присоединяетесь ли к группе, например, к странице и т. д. Для этих отношений создается новое ребро.  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-1.png)
Тогда весь facebook - это совокупность узлов и ребер. Это потому, что facebook использует структуру данных графа для хранения своих данных.  

Точнее, **граф** - это структура данных (V, E), которая состоит из:  
* Коллекция вершин V.
* Набор ребер E, представленный в виде упорядоченных пар вершин (u, v).

![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-2.png)  
Представлен граф  
```
V = {0, 1, 2, 3}
E = {(0,1), (0,2), (0,3), (1,2)}
G = {V, E}
```
### Терминология графа
* **Смежность**  
Говорят, что вершина смежна с другой вершиной, если есть ребро, соединяющее их.  
Вершины 2 и 3 не являются смежными, потому что между ними нет ребра.  
* **Путь**  
Последовательность ребер, которая позволяет вам перейти от вершины A к вершине B, называется путем.  
0-1, 1-2 и 0-2 являются путями от вершины 0 до вершины 2.  
* **Ориентированный граф**  
Граф, в котором есть ребро (u, v) не обязательно означает, что также имеется ребро (v, u). Ребра в таком графике представлены стрелками, чтобы показать направление ребра.  

## Способы представления графа
Графы обычно представлены двумя способами:  
### 1. Матрица смежности
__Матрица смежности__ - это двумерный (2D) массив V и V вершин. Каждая строка и столбец представляют вершину.  
Если значение любого элемента a[i][j] равно 1, это означает, что существует ребро, соединяющее вершину i и вершину j.  
Матрица смежности для графа, который мы создали выше.  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-3.png)  
Поскольку это неориентированный граф, для ребра (0,2) нам также нужно отметить ребро (2,0), делая матрицу смежности симметричной относительно диагонали.  

Поиск ребер (проверка, существует ли ребро между вершиной A и вершиной B), чрезвычайно быстр в представлении матрицы смежности, но мы должны зарезервировать пространство для каждой возможной связи между всеми вершинами (V x V), поэтому для этого требуется больше места.  

### 2. Список смежности
**Список смежности** представляет собой граф в виде массива связанного списка.  
Индекс массива представляет вершину, и каждый элемент в его связанном списке представляет другие вершины, которые образуют ребро с вершиной.  
Список смежности для графа, который мы создали в первом примере, выглядит следующим образом:  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-4.png)  
Список смежности эффективен с точки зрения хранения, потому что нам нужно хранить только значения для ребер. Для графа с миллионами вершин это может означать много сэкономленного пространства.  

## Операции над графами
Наиболее распространенные операции над графами:  
* Проверьте, присутствует ли элемент в графе.
* Обход графа.
* Добавить элементы (вершины, ребра) в граф.
* Нахождение пути от одной вершины к другой.  

Конспект сделал по [этой статье](https://evileg.com/ru/post/492/)  
Много примеров реализация различных структур данных на go есть [здесь (github)](https://github.com/maximelamure/algorithms/tree/d7cfe2f2953cf79c2dfc03152a92ac9e4635d45c/datastructure)

## DFS
Реализация графа и dfs:  
```golang
type Vertex struct {
	visited bool
	value string
	neighbours []*Vertex
}

func NewVertex(value string) *Vertex {
	return &Vertex{
		value:      value,
	}
}

func (v *Vertex) connect(vertex ...*Vertex) {
	v.neighbours = append(v.neighbours, vertex...)
}

type Graph struct{}

func (g *Graph) dfs(vertex *Vertex) {
	if vertex.visited {
		return
	}
	vertex.visited = true
	fmt.Println(vertex.value)
	for _, v := range vertex.neighbours {
		g.dfs(v)
	}
}

func (g *Graph) disconnected(vertex ...*Vertex) {
	for _, v := range vertex {
		g.dfs(v)
	}
}

func main() {
	v1 := NewVertex("A")
	v2 := NewVertex("B")
	v3 := NewVertex("C")
	v4 := NewVertex("D")
	v5 := NewVertex("E")
	g := Graph{}
	v1.connect(v2)
	v2.connect(v4, v5)
	v3.connect(v4, v5)
	g.dfs(v1)
}
```
Сам код взял [отсюда](https://codereview.stackexchange.com/questions/186035/dfs-implementation)  
Про DFS можно почитать на [хабре](https://habr.com/ru/post/200074/)  
Про BFS можно что-то почитать [здесь](https://evileg.com/ru/post/512/)  

## BFS
Поиск в ширину (Breadth first search, BFS).  
Стандартная реализация BFS помещает каждую вершина графа в одну из двух категорий:  
1. Посещенные  
2. Не посещенные  

Цель алгоритма: пометить каждую вершину графа как посещенную избегая циклов.  
Алгоритм:  
1. Начните с размещения любой вершины графа в конце очереди.
2. Возьмите передний элемент очереди и добавьте его в список посещенных.
3. Создайте список смежных узлов этой вершины. Добавьте те, которых нет в списке посещенных, в конец очереди.
4. Продолжайте повторять шаги 2 и 3, пока очередь не опустеет.  

Граф может иметь две разные несвязанные части, поэтому, чтобы убедиться, что мы покрываем каждую вершину, мы также можем запустить алгоритм BFS на каждом узле.  

Рассмотрим пример:  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-5.png)  
Мы начнем с вершины 0, алгоритм BFS начинается с помещения его в список посещенных и размещения всех смежных вершин в стеке.  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-6.png)  
Затем мы посещаем элемент в начале очереди, то есть 1, и переходим к соседним узлам. Так как 0 уже был посещен, мы посещаем 2.  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-7.png)  
У вершины 2 есть соседняя не посещенная вершина 4, поэтому мы добавляем ее в конец очереди и посещаем 3, которая находится в начале очереди.  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-8.png)  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-9.png)  
В очереди остается только 4, поскольку единственный соседний узел с 3, то есть 0, уже посещен. Мы посещаем вершину 4.  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-10.png)  

```golang
```

Конспект по BFS делал [отсюда](https://evileg.com/ru/post/512/)  
Реализацию его в go можно увидеть [здесь](https://cybernetist.com/2019/03/09/breadth-first-search-using-go-standard-library/)  


## Топологическая сортировка
Норм описано [здесь](https://habr.com/ru/post/100953/)  

[Использование обхода в глубину для поиска цикла](https://neerc.ifmo.ru/wiki/index.php?title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B0_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83_%D0%B4%D0%BB%D1%8F_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0_%D1%86%D0%B8%D0%BA%D0%BB%D0%B0)
