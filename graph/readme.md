# Граф. Структура данных.
__Структура данных графа__ представляет собой набор узлов, которые имеют данные и связаны с другими узлами.  

Давайте попробуем понять это на примере. На facebook все является узлом. Сюда входят пользователь, фотография, альбом, событие, группа, страница, комментарий, история, видео, ссылка, примечание ... все, что имеет данные, является узлом.  
Каждое отношение - это ребро от одного узла к другому. Публикуете ли вы фотографию, присоединяетесь ли к группе, например, к странице и т. д. Для этих отношений создается новое ребро.  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-1.png)
Тогда весь facebook - это совокупность узлов и ребер. Это потому, что facebook использует структуру данных графа для хранения своих данных.  

Точнее, **граф** - это структура данных (V, E), которая состоит из:  
* Коллекция вершин V.
* Набор ребер E, представленный в виде упорядоченных пар вершин (u, v).

![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-2.png)  
Представлен граф  
```
V = {0, 1, 2, 3}
E = {(0,1), (0,2), (0,3), (1,2)}
G = {V, E}
```
### Терминология графа
* **Смежность**  
Говорят, что вершина смежна с другой вершиной, если есть ребро, соединяющее их.  
Вершины 2 и 3 не являются смежными, потому что между ними нет ребра.  
* **Путь**  
Последовательность ребер, которая позволяет вам перейти от вершины A к вершине B, называется путем.  
0-1, 1-2 и 0-2 являются путями от вершины 0 до вершины 2.  
* **Ориентированный граф**  
Граф, в котором есть ребро (u, v) не обязательно означает, что также имеется ребро (v, u). Ребра в таком графике представлены стрелками, чтобы показать направление ребра.  

## Способы представления графа
Графы обычно представлены двумя способами:  
### 1. Матрица смежности
__Матрица смежности__ - это двумерный (2D) массив V и V вершин. Каждая строка и столбец представляют вершину.  
Если значение любого элемента a[i][j] равно 1, это означает, что существует ребро, соединяющее вершину i и вершину j.  
Матрица смежности для графа, который мы создали выше.  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-3.png)  
Поскольку это неориентированный граф, для ребра (0,2) нам также нужно отметить ребро (2,0), делая матрицу смежности симметричной относительно диагонали.  

Поиск ребер (проверка, существует ли ребро между вершиной A и вершиной B), чрезвычайно быстр в представлении матрицы смежности, но мы должны зарезервировать пространство для каждой возможной связи между всеми вершинами (V x V), поэтому для этого требуется больше места.  

### 2. Список смежности
**Список смежности** представляет собой граф в виде массива связанного списка.  
Индекс массива представляет вершину, и каждый элемент в его связанном списке представляет другие вершины, которые образуют ребро с вершиной.  
Список смежности для графа, который мы создали в первом примере, выглядит следующим образом:  
![](https://github.com/Chekunin/algorithms/blob/master/graph/graph-4.png)  
Список смежности эффективен с точки зрения хранения, потому что нам нужно хранить только значения для ребер. Для графа с миллионами вершин это может означать много сэкономленного пространства.  

## Операции над графами
Наиболее распространенные операции над графами:  
* Проверьте, присутствует ли элемент в графе.
* Обход графа.
* Добавить элементы (вершины, ребра) в граф.
* Нахождение пути от одной вершины к другой.  

Конспект сделал по [этой статья](https://evileg.com/ru/post/492/)
